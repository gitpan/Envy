# ghostwheel dimension multiplexer a la -*-perl-*-

# use 5.005;  ???
use strict;
package Envy::DB;
use integer;
use Carp;
use Symbol;
use Fcntl;
use vars qw(@ISA @EXPORT_OK $VERSION $EVERSION @DefaultPath
	    $LOGIN $Reloading $Context $Loop $Path);
@ISA = ('Exporter');
@EXPORT_OK = qw(@DefaultPath);
$VERSION = '2.17';

umask 0;  # Figure out how to run setuid 'envy' XXX

sub PATH() { 'ENVY_PATH' }
sub STATE() { 'ENVY_STATE' }
sub DIMENSION() { 'ENVY_DIMENSION' }
sub CONTEXT() { 'ENVY_CONTEXT' }

$EVERSION = 3;
sub EVERSION() { 'ENVY_VERSION' }

sub ERR() { 0 }
sub WARN() { 1 }
sub NOISY() { 2 }
sub DEBUG() { 3 }

# make all config variables available here? XXX

if ($ENV{REGRESSION_ENVY_PATH}) {
    @DefaultPath = split m/\s+/, $ENV{REGRESSION_ENVY_PATH};
} else {
    @DefaultPath = #SEARCH#
}

sub new { #PUBLIC
    my ($class, $env) = @_;
    my $o = bless {}, $class;
    my %env = $env? %$env : ();
    $o->{env} = \%env;
    $o->{delta} = {};    # which variables have changed
    $o->{'warn'} = [];   # warnings & error messages
    $o->{'log'} = [];      # log entries
    $o->{errors} = 0;
    $o->{where} = $o->{env}{ &CONTEXT } || 'shell';

    # MAKE SURE WE HAVE THE DEFAULT ENVY_PATH...
    my $fixed=0;
    my %old;
    my @path = split /:+/, $o->{env}{&PATH} || '';
    for (@path) { $old{$_} = 1 }
    for my $dir (@DefaultPath) {
	next if exists $old{$dir};
	push @path, $dir;
	$fixed=1;
    }
    if ($fixed) {
	$o->{env}{&PATH} = join ':', @path;
	$o->{delta}{&PATH} = 1;
    }

    $o;
}

# ---------------------------------------------------------------

sub w {
    my $o = shift;
    my $level = shift;
    my $w = join('', @_);
    $w .= $Context if $w !~ m/\n$/s;
    $w .= "\n" if $w !~ m/\n$/s;
    push @{$o->{'warn'}}, [$level, $w];
    ++$o->{errors} if $level == ERR;
    0
}

# help cope with backward compatibility
sub version {
    my ($o) = @_;
    $o->{env}{&EVERSION} || $EVERSION;
}

# ---------------------------------------------------------------

sub search_envy_path { #PRIVATE
    my ($o) = @_;
    $o->{fullpath} = {};
    $o->{shadowed} = {};

    my %PATH;
    my $add_path  = sub {
	my ($o, $p) = @_;
	
	return if exists $PATH{$p};
	$PATH{$p}=1;
	$o->w(DEBUG,"Reading $p...\n");
	
	my $dh = gensym;
	opendir($dh, $p) or return $o->w(DEBUG,"Directory '$p' not readable.\n");
	for my $m (readdir($dh)) {
	    next if $m !~ m/\.(mo|env)$/;
	    next if -d "$p/$m";
	    
	    if ($m =~ /[,\s]/) {
		$o->w(WARN, "Envy found containing commas '$p/$m' (ignored).\n");
		next;
	    }
	    $o->w(WARN, "Envy '$p/$m' should have .env suffix (ignored).\n")
		if $m !~ m/\.env$/;
	    
	    my $file = $m;
	    $m =~ s/\.(mo|env)$//;
	    if ($m =~ m/^\d$/) {
		$o->w(WARN, "Envy: '$p/$m' single digits are reserved\n");
		next;
	    }
	    if (!exists $o->{fullpath}{$m}) {
		$o->w(DEBUG,"\t$m=$p/$file\n");
		$o->{fullpath}{$m} = "$p/$file";
	    } else {
		push @{ $o->{shadowed}{$m} }, "$p/$file";
	    }
	}
	closedir($dh);
    };
    
    my @add = split /:+/, $o->{env}{&PATH};
    if (exists $o->{env}{'HOME'} and -d $o->{env}{'HOME'}."/.envy") {
	unshift @add, $o->{env}{'HOME'}."/.envy";
    }
    for my $p (@add) {
	$add_path->($o, $p);
	if (-d "$p/.priv") {
	    $add_path->($o, "$p/.priv")
	} elsif (-d "$p/.private") {
	    $o->w(WARN, "$p/.private should be renamed to $p/.priv\n");
	    $add_path->($o, "$p/.private");
	}
    }
}

sub get_fullpath {
    my ($o, $mo) = @_;
    $o->search_envy_path() if !exists $o->{fullpath};
    if (!defined $mo) {
	$o->{fullpath}
    } else {
	return if !exists $o->{fullpath}{$mo};
	$o->{fullpath}{$mo}
    }
}

# ---------------------------------------------------------------

# HOW ENVY_STATE WORKS:
#
# 0      - the first envy loaded
# 1      - top level (implicit dependency on first envy)
# <envy> - explicit dependency
# 2      - required by multiple envys

sub cache_state { #PRIVATE
    my ($o) = @_;

    my %loaded;
    for my $m (split /:+/, $o->{env}{&STATE} || '') {
	my ($k,$v) = split /,/, $m;
	$v = '0' if $v eq 'STARTUP';
	$loaded{$k}=$v;
    }
    $o->{loaded} = \%loaded;

    my %dimen = map { split /,/ } split /:+/, $o->{env}{&DIMENSION} || '';
    $o->{dimen} = \%dimen;
    $o->{first} = $o->{dimen}{First};
}

sub is_loaded {
    my ($o, $m) = @_;
    $o->cache_state() if !exists $o->{loaded};
    exists $o->{loaded}{$m};
}

sub is_unloaded {
    my ($o, $m) = @_;
    $o->cache_state() if !exists $o->{loaded};
    ! exists $o->{loaded}{$m};
}

sub is_first {
    if (@_ == 1) {
	my ($o) = @_;
	(keys %{$o->{loaded}}) == 0
    } elsif (@_ == 2) {
	my ($o, $mo) = @_;
	my $f = $o->{dimen}{First};
	$f && $f eq $mo
    }
}

sub loaded_by {
    my ($o, $by) = @_;
    $o->cache_state if !exists $o->{loaded};
    my $loaded = $o->{loaded};
    my @m;
    for my $mo (keys %$loaded) { push @m, $mo if $$loaded{$mo} eq $by }
    @m
}

sub set_loaded { #PRIVATE
    my ($o, $mo, $by) = @_;
    my $l = $o->{loaded};
    if ($o->is_first($mo)) {
	$l->{$mo} = '0';
    }
    elsif (!exists $l->{$mo}) {
	$l->{$mo} = $by;
    }
    elsif ($l->{$mo} !~ m/^\d$/ and $l->{$mo} ne $by) {
	$o->w(NOISY, "Envy '$mo' load by '$l->{$mo}' and now by '$by'");
	$l->{$mo} = '2';
    }
}

sub set_unloaded { #PRIVATE
    my ($o, $mo) = @_;
    delete $o->{loaded}{$mo}
}

sub nav_dimension { #PRIVATE
    my ($o, $reverse, $di, $by) = @_;
    my $old = $o->{dimen}{$di};
    if (!$reverse) {
	if ($o->is_first) {
	    $o->w(WARN, "Envy '$by' should use dimension 'First' instead of '$di'")
		if $di ne 'First';
	}
	elsif ($old and $old ne $by) {
	    $o->w(NOISY, "Swapping $di from '$old'");
	    $o->process_envy(1, $old, '1');
	}
	$o->{dimen}{$di} = $by;
	if ($di eq 'First') {
	    $o->{first} ||= $by;
	    $o->unload_all()
		if $o->{first} ne $by;
	}

    } else {
	$o->w(WARN, "Envy '$by' opening $di (was $old)")
	    if $old ne $by;
	$o->{dimen}{$di} = undef;
    }
}

sub depends_on {
    my ($o, $mo) = @_;
    $o->cache_state if !exists $o->{loaded};
    exists $o->{loaded}{$mo} and $o->{loaded}{$mo}
}

sub save_state { #PRIVATE
    my ($o) = @_;
    confess "save_state" if !exists $o->{loaded};

    # ENVY_PATH is adjusted like other variables; it does not concern us here

    my $dim = $o->{dimen};
    my @new = (&EVERSION => $EVERSION,
	       &STATE => join(':', map {"$_,$o->{loaded}{$_}"} sort
			      keys %{$o->{loaded}}),
	       &DIMENSION => join(':', map {"$_,$o->{dimen}{$_}"} sort
				  grep { defined $dim->{$_} } keys %$dim));
    while (@new) {
	my ($k,$v) = splice @new, -2;
	if (($o->{env}{$k} || '') ne $v) {
	    $o->{env}{$k} = $v;
	    $o->{delta}{$k} = 1;
	}
    }
}

# ---------------------------------------------------------------

sub catalogue {
    # read everything; get descriptions, dependencies, etc
    #
    # populate $o->{dimen}
    #
    # create $o->{info}{envy}
    #   {desc} = 'the description'
    #   {dimen} = dimension
    #   {requires} = [...]
    #
    # Sounds good?
}

# ---------------------------------------------------------------

sub tree_top {
    my ($base) = @_;
    $base =~ s,/etc/envy/.+?\.(mo|env)$,, or
	$base =~ s,/mo/.+?\.(mo|env)$,, or
	    $base =~ s,/.+?\.(mo|env)$,,;
    $base;
}

sub interpolate {
    my ($o, $qx, $str) = @_;
    my $subst = sub {
	my $var = shift;
	$var =~ tr [{}] []d;
	if ($var eq 'MODULE_BASE' or $var eq 'modulebase' or
	    $var eq 'ENVY_LINKBASE') {
	    $o->w(WARN,"$var is depreciated")
		if $var =~ /module/i;
	    return tree_top($Path);
	} elsif ($var eq 'MODULE_REALBASE' or $var eq 'ENVY_BASE') {
	    $o->w(WARN,"$var is depreciated")
		if $var =~ /module/i;
	    my $rbase = $Path;
	    while (-l $rbase) {
		$rbase = readlink($rbase) or die "readlink $rbase";
	    }
	    return tree_top($rbase);
	}
	return $o->w(WARN,"Variable '$var' not set"), '' if
	    !defined $o->{env}{$var};
	$o->{env}{$var};
    };
    # need to do real lexical analysis XXX
    if($str =~ /^\'(.*)\'$/){
	return $1;
    }
    if($str =~ /^\`(.*)\`$/){
	return `$1`;
    }
    while ($str =~ s/
	   \$ (
	       (:? \{[\w-]+\} ) |
	       (:?   [\w-]+   )
	       )
	   /&$subst($1)/exg) {};
    $str;
}

sub edit_key {
    my ($o, $k) = @_;
    if ($k eq 'MODULE_PATH') {
	$o->w(WARN,"'$k' is depreciated; use ".&PATH);
	$k = &PATH;
    }
    return $o->w(WARN,"Variable '$k' is not alpha-numeric") if
	$k !~ /^[\w-]+$/;
    return $o->w(WARN,"Naughty naughty, '$k' is private") if
	($k eq &STATE or $k eq &DIMENSION or
	 $k eq 'ENVY_BASE' or $k eq 'ENVY_LINKBASE');
    $o->{delta}{$k}=1;
    $k;
}

sub assign {
    my ($o, $reverse, $k, $force, $v) = @_;
    $k = $o->edit_key($k);
    return if !$k;
    return $o->w(ERR,"Variable '$k' must be edited with +=")
	if ($k eq 'PATH' or $k eq 'MANPATH' or $k eq &PATH);
    if (!$reverse) {
	$o->w(NOISY,"Variable '$k' redefined") if
	    (!$force and exists $o->{env}{$k} and !$Reloading);
	$o->{env}{$k} = $o->interpolate(1,$v);
    }
    else {
	delete $o->{env}{$k};
    }
}

sub rejoin {
    my ($o, $reverse, $k, $prepend, $sep, $v) = @_;
    $k = $o->edit_key($k);
    return if !$k;

    # SPECIAL CASES:
    #
    # PATH      - don't remove ourselves from the path
    #             '.' is always kept first if it is seen
    #             if switching to a new envy.pl:
    #                abort subsequent loads
    #
    # ENVY_PATH - never remove components
    #             rescan all directories for .env files

    # fetch old list
    my @old = split /$sep+/, $o->{env}{$k} if defined $o->{env}{$k};
    my %old; for (@old) { $old{$_}=1; }
    
    # fetch delta
    my @delta = split /$sep+/, $o->interpolate(0,$v);
    my %delta; for (@delta) { $delta{$_}=1 }
    
    # filter @old with @delta -> @now
    my @now;
    if ($k eq &PATH) {
	if (!$reverse) {
	    push @now, @delta if $prepend;
	    for my $p (@old) { push @now, $p if !exists $delta{$p} }
	    push @now, @delta if !$prepend;
	}
    }
    elsif ($k eq 'PATH') {
	my $has_dot = exists $old{'.'};
	push @now, @delta if $prepend && !$reverse;
	
	for my $p (@old) {
	    if (!$reverse and exists $delta{$p} and $p ne '.') {
		$o->w(NOISY, "Component '$p' added to '$k' again")
		    if !$Reloading;
		next
	    }
	    next if delete $delta{$p} || $p eq '.';
	    push @now, $p;
	}

	push @now, @delta if !$prepend && !$reverse;
	unshift @now, '.' if $has_dot; # once sloppy; keep sloppy
    }
    else {
	push @now, @delta if $prepend && !$reverse;
	for my $p (@old) {
	    if (!$reverse and exists $delta{$p}) {
		$o->w(NOISY, "Component '$p' added to '$k' again")
		    if !$Reloading;
		next
	    }
	    next if delete $delta{$p};
	    push @now, $p;
	}
	push @now, @delta if !$prepend && !$reverse;
    }

    $o->{env}{$k} = join $sep, @now;
    $o->search_envy_path() if $k eq &PATH;
}

sub process_envy { #PRIVATE
    my ($o, $reverse, $mo, $prior) = @_;
    confess $o if @_ != 4;

    return if $o->{errors} > 5;
    return $o->w(WARN, "Dimension 'First' changed from '$o->{first}'; must restart envy")
	if !$reverse && $o->{first} && !$o->is_first($o->{first});

    local $Path = $o->get_fullpath($mo);
    return $o->w(ERR,"Can't find envy '$mo'")
	if !$Path;
    local $Loop = $Loop+1;
    return $o->w(ERR,"Recursive reloading detected")
	if $Loop>100;
    $o->w(WARN,"Envy '$mo' is already unloaded")
	if $reverse && $o->is_unloaded($mo);

    local $Reloading = !$reverse && $o->is_loaded($mo);
    my @L;
    {
	my $fh = gensym;
	open($fh, $Path) or
	    return $o->w(ERR,"Envy '$mo' ($Path) is not readable.");
	@L = <$fh>;
	close $fh;
    }
    my $seen_stuff=0;
    my $prechange = sub {
	return if $seen_stuff;
	$seen_stuff = 1;
	if (!$reverse and $o->is_first and !$o->is_first($mo)) {
	    $o->w(WARN, "Envy '$mo' should use dimension 'First'");
	    $o->nav_dimension($reverse, 'First', $mo);
	}
    };
    my $doline = sub {
	my $line = shift;
	my $l = $L[$line-1];

	# need a real lexer; '#' cannot be hidden by quoting! XXX
	# get rid of comment lines & trailing whitespace
	$l =~ s/ \s* (\#.*)? $//sx;
	return if !length $l;

	local $Context = " at envy '$mo' line $line\n\t".$Context;

	if ($l =~ /^(alpha|beta|depreciated)$/) {
	    $o->w(WARN,"Envy '$mo' is ".uc($1).", use at your own risk")
		if !$reverse;
	    
	} elsif ($l =~ s/^dimension\s+//) {
	    # allow multiple dimensions? variable substitution? XXX
	    return $o->w(ERR, "Dimensions must be declared firstly")
		if $seen_stuff && !$reverse;
	    return $o->w(ERR, "Bad dimension name '$l'")
		if $l !~ m/^[\w-]+$/;
	    $o->nav_dimension($reverse, $l, $mo);

	} elsif ($l =~ m/^require\s+Envy\s+([\d\.]+)$/) {
	    my $v = $1;
	    return $o->w(ERR, "Envy '$mo' requires envy $v")
		if $v > $VERSION;

	} elsif ($l =~ s/^require\s+//) {
	    $prechange->();
	    my $str = $o->interpolate(0,$l);
	    return $o->w(ERR,"Bad characters in require '$str'")
		if $str !~ /^[\w-.]+$/;
	    if (!$reverse == !$o->is_loaded($str)) {
		$o->process_envy($reverse, $str, $mo);
	    } elsif (!$reverse) {
		$o->set_loaded($str, $mo);
	    }

	} elsif ($l =~ s/^desc(ription)?\s//) {
	    # save somewhere XXX

	} elsif ($l =~ s/^(echo|error)\s?//) {
	    $o->w($1 eq 'echo'? WARN : ERR, $o->interpolate(1,$l)."\n")
		if !$reverse;

	} elsif ($l =~ /^([\w-]+) (\+\=|\=\+) (.*)$/x) { # PATH=+ gotcha
	    my @got = ($1, $2 eq '+=', ':', $3);
	    $prechange->();
	    $o->rejoin($reverse, @got);

	} elsif ($l =~ /^([\w-]+) (:)?= (.*)$/x) {
	    my @got = ($1,$2,$3);
	    $prechange->();
	    $o->assign($reverse, @got);

	} else {
	    # maybe a newer version of envy knows about new tokens...
	    $o->w(NOISY, "Inexplicable ignored: '$l'");
	}
    };

    if (!$reverse) {
	for (my $line_no = 1; $line_no <= @L; $line_no++) {
	    $doline->($line_no);
	    last if $o->{errors} > 5;
	}
    } else {
	for (my $line_no = @L; $line_no >= 1; $line_no--) {
	    $doline->($line_no);
	    last if $o->{errors} > 5;
	}
    }

    if ($reverse) {
	$o->set_unloaded($mo);
    } else {
	$o->set_loaded($mo, $prior);
    }

    $LOGIN ||= getlogin || getpwuid($<) || "?";
    push @{$o->{'log'}}, { when => time(), who => $LOGIN,
			 action => ($reverse?'un':'').'load', what => $mo };
}

# ---------------------------------------------------------------

sub check_fuzzy { #PUBLIC
    my ($o, $mo) = @_;
    $o->w(WARN,"Envy: non-interactive fuzzy match used to load '$mo'.\n  Please use 'envy load $mo' instead of just 'envy $mo'!\n")
	if $o->{where} ne 'shell';
}

sub unload_all { #PUBLIC
    my ($o) = @_;
    $Loop = 0;
    $Context = " while unloading everything.\n";
    for my $phase (1..2) {
	for my $m ($o->loaded_by($phase)) {
	    $o->process_envy(1, $m, $phase) if !$o->is_unloaded($m);
	}
    }
}

sub do_envy { #PUBLIC
    carp "depreciated";
    my ($o, $mo, $rev) = @_;
    $o->envy($rev, $mo);
}

sub envy { #PUBLIC
    my ($o, $reverse, $mo) = @_;
    if ($reverse and $o->is_first($mo)) {
	$o->unload_all();
    } else {
	$Loop = 0;
	$Context = " while ".($reverse?"un":"")."loading envy '$mo'.\n";
	$o->process_envy($reverse, $mo, '1');
    }
}

sub write_log { #PUBLIC
    my ($o) = @_;
    require FindBin;
    my $file = "$FindBin::Bin/../var/envy.log";
    my @stat = stat($file);
    if (@stat and $stat[7] > 1024 * 256) {
	$o->w(WARN, "envy: rename $file $file.old: $!\n")
	    if !rename $file, "$file.old";
    }
    my $LOG = gensym;
    sysopen($LOG, $file, &O_WRONLY| &O_APPEND| &O_CREAT, 0666) or
	return $o->w(NOISY, "envy: open $file: $!");
    for my $e (@{$o->{'log'}}) {
	print $LOG (join("\t", scalar localtime($e->{when}),
			 $e->{who}, $o->{where}, $e->{action}, $e->{what})."\n");
    }
}

sub warnings { #PUBLIC
    my ($o, $level) = @_;
    my $all = $o->{'warn'};
    $o->{'warn'} = [];
    $level = 1 if !defined $level;
    map { $_->[1] } grep { $_->[0] <= $level } @$all;
}

sub to_sync { #PUBLIC
    my ($o) = @_;
    return if $o->{errors};
    $o->save_state();
    my $delta = $o->{delta};
    $o->{delta} = {};
    sort {$a->[0] cmp $b->[0]} map { [$_,$o->{env}{$_}] } keys %$delta;
}

sub status { #PUBLIC
    my ($o) = @_;
    $o->cache_state if !exists $o->{loaded};
    my @loaded = keys %{$o->{loaded}};
    ($o->get_fullpath(),\@loaded);
}

1;
