#-*-perl-*-

package Envy::DB;
use strict;
use integer;
use Carp;
use Symbol;
use IO::File;
use vars qw($VERSION $EVERSION $LOG $LOGIN);

$VERSION = '2.13';

sub PATH() { 'ENVY_PATH' }
sub STATE() { 'ENVY_STATE' }
sub DIMENSION() { 'ENVY_DIMENSION' }
sub CONTEXT() { 'ENVY_CONTEXT' }

$EVERSION = 3;
sub EVERSION() { 'ENVY_VERSION' }

sub new {
    croak "Envy::DB->new([env])" if @_ != 2;
    my ($class, $env) = @_;
    my $o = bless { fuzzy=>0, 'log'=>1 }, $class;
    $o->reset($env) if $env;
    $o;
}

sub fuzzy {
    my ($o, $yes) = @_;
    $o->{fuzzy} = $yes if @_ == 2;
    $o->{fuzzy};
}

sub do_log {
    my ($o, $yes) = @_;
    $o->{'log'} = $yes if @_ == 2;
    $o->{'log'};
}

sub debug {
    my ($o, $yes) = @_;
    $o->{'debug'} = $yes if defined $yes;
    $o->{'debug'};
}

sub reset {
    my ($o, $env) = @_;
    $o->{delta} = {};
    my %env = %$env;
    $o->{env} = \%env;
    $o->{etop} = $o->{env}{ETOP} || '';
    for (&PATH, &STATE, &DIMENSION) { $o->{env}{$_} ||= ''; }
    $o->{'warn'} ||= [];
}

sub _warn {
    my $o = shift;
    my $w = join('', @_);
    $w .= "\n" if $w !~ m/\n$/;
    push(@{$o->{'warn'}}, $w);
}

sub version {
    my ($o) = @_;
    $o->{env}{&EVERSION} || $EVERSION;
}

sub strip_base {
    my ($base) = @_;
    $base =~ s,/mo/.+?\.(mo|env)$,,;
    $base =~ s,/etc/envy/.+?\.(mo|env)$,,;
    $base;
}

sub _subst {
    my ($o, $str, $base, $context) = @_;
    my $subst = sub {
	my $var = shift;
	$var =~ tr [{}] []d;
	if ($var eq 'MODULE_BASE' or $var eq 'modulebase' or
	    $var eq 'ENVY_LINKBASE') {
	    $o->_warn("$var is depreciated".$context)
		if $var =~ /module/i;
	    return strip_base($base);
	} elsif ($var eq 'MODULE_REALBASE' or $var eq 'ENVY_BASE') {
	    $o->_warn("$var is depreciated".$context)
		if $var =~ /module/i;
	    my $rbase = $base;
	    while (-l $rbase) {
		$rbase = readlink($rbase) or die "readlink $rbase";
	    }
	    return strip_base($rbase);
	}
	do { $o->_warn("Variable '$var' not set".$context); return '' } if
	    !defined $o->{env}{$var};
	$o->{env}{$var};
    };
    while ($str =~ s/
	   \$ (
	       (:? \{[\w\d_-]+\} ) |
	       (:?   [\w\d_-]+   )
	       )
	   /&$subst($1)/exg) {};
    $str;
}

sub add_path {
    my ($o, $p) = @_;
    return if $o->{path}{$p};
    $o->{path}{$p} = 1;
    $o->_warn("Reading $p...") if $o->debug;
    my $dh = gensym;
    opendir($dh, $p) or do {
#	$o->_warn("Could not read directory '$p' (warning).");
	return;
    };
    for my $m (readdir($dh)) {
	next if ($m =~ /^\.+$/ or -d "$p/$m");
	if ($m =~ /[,\s]/)
	{ $o->_warn("Envy found containing commas '$p/$m' (ignored)."); next; }
	if ($m !~ /\.(mo|env)$/) {
	    if ($p =~ m,etc/envy, and $m !~ m/\.env$/) {
		$o->_warn("Envy with bad suffix '$p/$m'.");
	    }
	    next;
	}

	my $file = $m;
	$m =~ s/\.(mo|env)$//;
	next if defined $o->{cache}{$m};
	$o->_warn("\t$m=$p/$file") if $o->debug;
	$o->{cache}{$m} = "$p/$file";
    }
    closedir($dh);
}

sub cache_path {
    my ($o, $mo) = @_;
    return if $o->{cache};
    confess "cache_state before cache_path" if exists $o->{state};
    $o->{cache} = {};
    if ($mo and $mo =~ m-^/- and -d $mo) {
	$o->{cache}{$mo} = "$mo/.envy";  # ~username
    }

    my $path;
    $path = $o->{env}{&PATH} || '';

    my @default;
    if ($ENV{REGRESSION_PATH}) {
	@default = split(m/\s+/, $ENV{REGRESSION_PATH});
    } else {
	@default = #SEARCH#;
    }

    my @to_add = (split(/:+/, $path), @default);
    for my $p (@to_add) {
	$o->add_path($p);
    }
}

=head1 ENVY STATE

STARTUP - set ETOP on login
1 - top level
<envy> - depends on given envy
2 - required by multiple envys

=cut

sub cache_state {
    my ($o) = @_;
    return if exists $o->{state};
    my %state;
    my %dimen;

    for my $m (split(/:+/, $o->{env}{&STATE})) {
	my ($k,$v) = split(/,/, $m);
	$state{$k}=$v;
	if (!$o->{cache}{$k} and $k =~ m-^/- and -d $k) {
	    $o->{cache}{$k}="$k/.envy";
	}
    }
    %dimen = map { split(/,/) } split(/:+/, $o->{env}{&DIMENSION});
    
    $o->{dimen} = \%dimen;
    $o->{state} = \%state;
}

sub write_state {
    my ($o) = @_;
    confess "write_state of nothing" if (!$o->{state} or !$o->{dimen});

    # current version
    $o->{env}{&EVERSION} = $EVERSION;
    $o->{env}{&STATE} =
	join(':',map {"$_,$o->{state}{$_}"} sort keys %{$o->{state}});
    $o->{env}{&DIMENSION} =
	join(':',map {"$_,$o->{dimen}{$_}"} sort keys %{$o->{dimen}});
    for (&STATE, &DIMENSION, &EVERSION) { $o->{delta}{$_} = 1; }

    # cleanup
    delete $o->{state};
    delete $o->{dimen};
}

sub write_path {
    my ($o) = @_;
}

sub can_edit {
    my ($o, $k, $ctx) = @_;
    do { $o->_warn("Variable '$k' is not alpha-numeric".$ctx); return 0} if
	$k !~ /[\w\d_-]+/;
    do { $o->_warn("Naughty naughty, $k is private".$ctx); return 0} if
	($k eq &STATE or $k eq &DIMENSION);
    $o->{delta}{$k}=1;
    1;
}

sub is_unloaded {
    my ($o, $m) = @_;
    $o->cache_state();
    ! $o->{state}{$m};
}

sub do_envy {
    my ($o, $mo, $reverse) = @_;
    $o->cache_path($mo);
    $o->cache_state();
    $o->{context} = $o->{env}{ &CONTEXT } || 'shell';
    $o->_warn("Envy: non-interactive fuzzy match used to load '$mo'.\n  Please switch to 'envy load $mo' instead of just 'envy $mo'!\n")
	if $o->{context} ne 'shell' && $o->fuzzy;
    if ($reverse and ($o->{state}{$mo} || '') eq 'STARTUP') {
	warn "Envy: unloading '$mo' would cause envy itself to be unloaded!\n  Please try 'envy unload' instead.\n";
	exit 1;
    }
    _exe($o, $reverse, $mo,
	 " while ".($reverse?"un":"")."loading envy '$mo'.\n", '1', 0);
    $o->write_state();
    $o->write_path();
}

sub unload_all {
    my ($o) = @_;
    for my $phase (1..2) {
	for my $m ($o->to_unload($phase)) {
	    $o->do_envy($m, 1) if !$o->is_unloaded($m);
	}
    }
}

sub _exe {
    my ($o, $reverse, $mo, $context, $prior, $loop) = @_;
    ++$loop;
    confess $o if @_ != 6;

    do { $o->_warn("Can't find envy '$mo'".$context); return; } if
	!defined $o->{cache}{$mo};
    do { $o->_warn("Envy '$mo' is already unloaded".$context); return; } if
	$reverse && $o->is_unloaded($mo);
    do { $o->_warn("Recursive reloading detected".$context); return;} if $loop>100;

    $o->unload_all() if $reverse and $o->{state}{$mo} eq 'STARTUP';

    my $base = (my $path = $o->{cache}{$mo});
    $o->{etop} ||= $o->{env}{ETOP};
    my $etop_set=0;

    my @file;
    {
	my $fh = new IO::File;
	$fh->open($path) or
	    do { $o->_warn("Envy '$mo' ($path) is not readable."); return };
	@file = $reverse? reverse <$fh> : <$fh>;
    }
    my $first=1;
    for (my $line=1; $line <= @file; $line++) {
	my $l = $file[$line-1];
	$l =~ s/\s*\#.*$//;
	next if $l =~ /^\s*$/;
	my $ctx = " at envy '$mo' line $line\n\t".$context;

	if ($l =~ /^require\s+(\S+)/) {
	    $first=0;
	    my $str = $o->_subst($1, $base, $ctx);
	    $o->_warn("Inappropriate whitespace detected".$context)
		if $str =~ /\s/;
	    if (!$reverse or ($reverse and (!exists $o->{state}{$str} or 
					    $o->{state}{$str} ne '2'))) {
		$o->_exe($reverse, $str, $ctx, $mo, $loop);
	    }

	} elsif ($l =~ /^depreciated$/) {
	    $o->_warn("Envy '$mo' is DEPRECIATED".$context)
		if !$reverse;

	} elsif ($l =~ /^dimension\s+(\S+)\s*$/) {
	    my $di = $1;
	    if ($reverse) {
		delete $o->{dimen}{$di};
	    } else {
		die "Dimensions must be listed first".$context if !$first;
		if (exists $o->{dimen}{$di} and $o->{dimen}{$di} ne $mo) {
		    $o->_warn("Swapping $di from '$o->{dimen}{$di}'".$context);
		    $o->_exe(1,$o->{dimen}{$di}, $ctx, $mo, $loop);
		}
		$o->{dimen}{$di} = $mo;
	    }

	} elsif ($l =~ /^echo\s(.*)$/) {
	    my $str = $o->_subst($1, $base, $ctx);
	    $str .= "\n" if $str !~ m,\n$,;
	    $o->_warn($str) if !$reverse && $o->{context} eq 'shell';

	} elsif ($l =~ /^([^=+]+)=(.*)$/) {
	    $first=0;
	    my ($k,$v) = ($1,$2);
	    next if !$o->can_edit($k, $ctx);
	    do {$o->_warn("Variable '$k' must be edited with +=".$ctx);next} if
		($k eq 'PATH' or $k eq 'MANPATH' or $k eq &PATH);

	    if ($reverse) {
		delete $o->{env}{$k};
	    } else {
		do {$o->_warn("Variable '$k' redefined".$ctx) } if
		    (exists $o->{env}{$k} and !exists $o->{state}{$mo});
		$o->{env}{$k} = $o->_subst($v, $base, $ctx);
		++$etop_set if $k eq 'ETOP';
	    }

	} elsif ($l =~ /^([^=+]+)\+\=(.*)$/) {
	    $first=0;
	    my ($k,$v) = ($1,$2);
	    if ($k eq 'MODULE_PATH') {
		$o->_warn("$k is depreciated".$ctx);
		$k = &PATH;
	    }
	    next if !$o->can_edit($k, $ctx);
	    my $vsubst = $o->_subst($v, $base, $ctx);
	    $o->_warn("Inappropriate whitespace detected".$context)
		if $vsubst =~ /\s/;

	    # fetch delta
	    my @delta = split(/:+/, $vsubst);
	    my %delta;
	    for (@delta) { $delta{$_}=1 }
	    $delta{'.'}=1 if $k eq 'PATH';

	    # fetch old list
	    my @old = defined $o->{env}{$k}? split(/:+/, $o->{env}{$k}) : ();
	    my %old;
	    for (@old) { $old{$_}=1; }
	    my $has_dot = exists $old{'.'};

	    # filter @old with @delta -> @now
	    my @now=();
	    for my $e (@old) {
		if (!$reverse and exists $old{$e} and exists $delta{$e}
		    and $e ne '.') {
		    $o->_warn("Component '$e' added to '$k' again".$ctx)
			if !exists $o->{state}{$mo} && $k ne &PATH;
		}
		if (exists $delta{$e}) { delete $delta{$e}; next; }
		push(@now, $e);
	    }
	    if (!$reverse or $k eq &PATH) {
		# add @delta back
		for my $z (reverse @delta) {
		    $o->add_path($z) if $k eq &PATH;
		    if ($reverse) { push(@now, $z) }
		    else { unshift(@now, $z); }
		}
	    }
	    unshift(@now, '.') if $k eq 'PATH' && $has_dot;
	    $o->{env}{$k} = join(':', @now);

	} else {
	    $o->_warn("Inexplicable ignored: $l".$ctx);
	}
    }
    if ($reverse) { 
	delete $o->{state}{$mo};
    } else {
	$prior = 'STARTUP' if $prior eq '1'&& exists $o->{env}{ETOP} && $etop_set;
	my $cur = $o->{state}{$mo};
	if ($cur and $cur !~ m/^\d+$/ and $prior ne '1' and $cur ne $prior) {
	    # dependency conflict - set to phase 2 for unload all
	    $o->{state}{$mo}='2';
	    $o->_warn("Envy '$mo' also loaded by '$cur'".$context)
	} elsif (!$cur) {
	    $o->{state}{$mo}=$prior;
	}
    }
    if ($o->do_log() and $o->{etop}) {
	$LOGIN ||= getlogin || getpwuid($<) || "?";
	my $file = $o->{etop} . "/var/envy.log";
	if (!$LOG) {
	    $LOG = new IO::File;
	    $LOG->open($file, O_WRONLY|O_APPEND|O_CREAT, 0666) 
		or warn "envy: open $file: $!";
	}
	$LOG->print(join("\t", scalar(localtime), $LOGIN, $o->{context},
			 ($reverse? 'un':'').'load', $mo)."\n")
	    if $LOG->opened;
    }
}

sub warnings {
    my ($o) = @_;
    @{$o->{'warn'}};
}

sub to_sync {
    my ($o) = @_;
    sort {$a->[0] cmp $b->[0]} map { [$_,$o->{env}{$_}] } keys(%{$o->{delta}});
}

sub to_unload {
    my ($o, $phase) = @_;
    $o->cache_state;
    my @loaded;
    for my $mo (keys %{$o->{state}}) {
	push(@loaded, $mo) if $o->{state}{$mo} eq $phase;
    }
    @loaded;
}

sub status {
    my ($o) = @_;
    $o->cache_path();
    $o->cache_state;
    my @loaded;
    for my $mo (keys %{$o->{state}}) {
	push(@loaded, $mo) if $o->{state}{$mo};
    }
    ($o->{cache},\@loaded);
}

1;
